<!DOCTYPE html>
<html>
<head>
  <title>Raycaster with Transparent Shorter Walls</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black;
      height: 100%; width: 100%;
    }
    canvas { display: block; }
    #fullscreenBtn {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1000;
      padding: 8px 12px;
      background: #222;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <button id="fullscreenBtn">Go Fullscreen</button>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    document.getElementById("fullscreenBtn").onclick = () => {
      if (!document.fullscreenElement)
        document.documentElement.requestFullscreen();
      else
        document.exitFullscreen();
    };

    let floor1 = [
      "####################",
      "#..................#",
      "#..................#",
      "#.......I..........#",
      "#.......D..........#",
      "#..................#",
      "#.......######.....#",
      "#.......#....#.....#",
      "#.......#....#.....#",
      "#.......#....#.....#",
      "#........B####.....#",
      "#..................#",
      "#..................#",
      "#..................#",
      "#..................#",
      "####################"
    ];

    // Wall heights: 1.0 = full tall, 0.5 = medium, 0.2 = very short
    // Also assign colors for short walls as grey.
    let wallHeights = floor1.map(row =>
      row.split('').map(cell => {
        if (cell === '#') return 1.0;    // Tallest walls
        if (cell === 'B') return 0.2;    // Very short walls
        if (cell === 'D') return 0.5;    // Medium height walls
        if (cell === 'I') return 0;      // No wall (item or empty)
        return 0;
      })
    );

    let posX = 8.5, posY = 10.5;
    let dirX = 1, dirY = 0;
    let planeX = 0, planeY = 0.66;
    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    function gameLoop() {
      const w = canvas.width, h = canvas.height;
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, w, h);

      for (let x = 0; x < w; x++) {
        const cameraX = 2 * x / w - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;

        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);

        let sideDistX, sideDistY;
        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let stepX, stepY, side, hit = 0;

        if (rayDirX < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }

        if (rayDirY < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }

        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          if (wallHeights[mapY][mapX] > 0) hit = 1;
        }

        const perpWallDist = side === 0
          ? (mapX - posX + (1 - stepX) / 2) / rayDirX
          : (mapY - posY + (1 - stepY) / 2) / rayDirY;

        // Wall height factor
        const heightLevel = wallHeights[mapY][mapX];

        // Base line height without scaling
        const baseLineHeight = Math.floor(h / perpWallDist);

        // Scale line height by wall height factor
        const lineHeight = baseLineHeight * heightLevel;

        // Calculate full height line start and end (for full tall wall)
        const fullHeightLine = baseLineHeight;
        const heightDiff = fullHeightLine - lineHeight;

        // Position so that bottom stays roughly the same
        const drawStart = Math.floor((h / 2) - (lineHeight / 2) + heightDiff);
        const drawEnd = Math.floor(drawStart + lineHeight);

        // Choose color and transparency:
        // For short walls (height < 1), draw full height line in grey,
        // then clear (transparent) the area above the short visible part.

        if (heightLevel < 1) {
          // Draw full height wall line in grey (darker if side)
          const greyValue = side ? 100 : 150;
          ctx.strokeStyle = `rgba(${greyValue},${greyValue},${greyValue},1)`;
          ctx.beginPath();
          ctx.moveTo(x, (h/2) - (fullHeightLine/2));
          ctx.lineTo(x, (h/2) + (fullHeightLine/2));
          ctx.stroke();

          // Draw transparent rectangle above the visible short wall part to simulate "cut off"
          ctx.clearRect(
            x,                      // x position
            (h/2) - (fullHeightLine/2), // top of full wall line
            1,                      // width 1 px column
            heightDiff              // height to clear above short wall
          );

          // Draw visible short wall part (solid grey)
          ctx.strokeStyle = `rgba(${greyValue},${greyValue},${greyValue},1)`;
          ctx.beginPath();
          ctx.moveTo(x, drawStart);
          ctx.lineTo(x, drawEnd);
          ctx.stroke();

        } else {
          // Full height walls: white or lighter color, no transparency
          const colorValue = side ? 180 : 255;
          ctx.strokeStyle = `rgb(${colorValue},${colorValue},${colorValue})`;
          ctx.beginPath();
          ctx.moveTo(x, drawStart);
          ctx.lineTo(x, drawEnd);
          ctx.stroke();
        }
      }

      // Movement and rotation speeds
      const moveSpeed = 0.05;
      const rotSpeed = 0.03;

      if (keys['w'] || keys['arrowup']) {
        const forwardX = posX + dirX * moveSpeed;
        const forwardY = posY + dirY * moveSpeed;
        if (wallHeights[Math.floor(posY)][Math.floor(forwardX)] === 0) posX = forwardX;
        if (wallHeights[Math.floor(forwardY)][Math.floor(posX)] === 0) posY = forwardY;
      }

      if (keys['s'] || keys['arrowdown']) {
        const backX = posX - dirX * moveSpeed;
        const backY = posY - dirY * moveSpeed;
        if (wallHeights[Math.floor(posY)][Math.floor(backX)] === 0) posX = backX;
        if (wallHeights[Math.floor(backY)][Math.floor(posX)] === 0) posY = backY;
      }

      if (keys['arrowleft']) {
        const oldDirX = dirX;
        dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
        dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
        const oldPlaneX = planeX;
        planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
        planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
      }

      if (keys['arrowright']) {
        const oldDirX = dirX;
        dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
        dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
        const oldPlaneX = planeX;
        planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
        planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
      }

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
