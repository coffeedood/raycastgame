<!DOCTYPE html>
<html>
<head>
  <title>Raycaster with 3D Floor Items</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black;
      height: 100%; width: 100%;
    }
    canvas { display: block; margin: auto; background: #111; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const w = canvas.width = window.innerWidth;
const h = canvas.height = window.innerHeight;

// Map is 24x24 but with smaller tiles (map doubled in size)
const MAP_SIZE = 24;
const TILE_SIZE = 0.5; // Each tile is half size in world units (walls are bigger on map scale)
const WALL_HEIGHT = 1.0;

const map = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Doors map: 2 means door
// Example: put some doors at these positions
map[10][10] = 2;
map[10][11] = 2; // double wide door

map[14][15] = 2;
map[14][16] = 2; // another double door

// Player pos - somewhere inside the map
let posX = 12.5;
let posY = 12.5;
let dirX = -1;
let dirY = 0;
let planeX = 0;
let planeY = 0.66;

// Movement speed
const moveSpeed = 0.05;
const rotSpeed = 0.03;

// Items on the map, at normal scale coordinates (not doubled)
const items = [
  { x: 13.5, y: 10.5, name: "Gold" },
  { x: 15.2, y: 13.8, name: "Potion" },
  { x: 11.3, y: 14.4, name: "Key" }
];

// Key controls
const keys = {};
window.addEventListener("keydown", e => { keys[e.key] = true; });
window.addEventListener("keyup", e => { keys[e.key] = false; });

function update() {
  if(keys["w"]) {
    const nextX = posX + dirX * moveSpeed;
    const nextY = posY + dirY * moveSpeed;
    if(map[Math.floor(nextX)][Math.floor(posY)] === 0) posX = nextX;
    if(map[Math.floor(posX)][Math.floor(nextY)] === 0) posY = nextY;
  }
  if(keys["s"]) {
    const nextX = posX - dirX * moveSpeed;
    const nextY = posY - dirY * moveSpeed;
    if(map[Math.floor(nextX)][Math.floor(posY)] === 0) posX = nextX;
    if(map[Math.floor(posX)][Math.floor(nextY)] === 0) posY = nextY;
  }
  if(keys["a"]) {
    // rotate left
    const oldDirX = dirX;
    dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
    dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
    const oldPlaneX = planeX;
    planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
    planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
  }
  if(keys["d"]) {
    // rotate right
    const oldDirX = dirX;
    dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
    dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
    const oldPlaneX = planeX;
    planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
    planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
  }
}

// Raycasting and drawing
function render() {
  ctx.clearRect(0, 0, w, h);

  // Draw ceiling
  ctx.fillStyle = "#333";
  ctx.fillRect(0, 0, w, h / 2);

  // Draw floor
  ctx.fillStyle = "#777";
  ctx.fillRect(0, h / 2, w, h / 2);

  // Raycasting for each vertical stripe (column)
  for(let x = 0; x < w; x++) {
    // Calculate ray position and direction
    const cameraX = 2 * x / w - 1; // camera space x coordinate in [-1, 1]
    const rayDirX = dirX + planeX * cameraX;
    const rayDirY = dirY + planeY * cameraX;

    // Map coordinates of player
    let mapX = Math.floor(posX);
    let mapY = Math.floor(posY);

    // Length of ray from current position to next x or y side
    let sideDistX;
    let sideDistY;

    // Length of ray from one x or y side to next x or y side
    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);

    let perpWallDist;

    // Direction to step in x or y (+1 or -1)
    let stepX;
    let stepY;

    let hit = 0; // was there a wall hit?
    let side; // was a NS or EW wall hit?

    // Calculate step and initial sideDist
    if(rayDirX < 0) {
      stepX = -1;
      sideDistX = (posX - mapX) * deltaDistX;
    } else {
      stepX = 1;
      sideDistX = (mapX + 1.0 - posX) * deltaDistX;
    }
    if(rayDirY < 0) {
      stepY = -1;
      sideDistY = (posY - mapY) * deltaDistY;
    } else {
      stepY = 1;
      sideDistY = (mapY + 1.0 - posY) * deltaDistY;
    }

    // Perform DDA
    while(hit === 0) {
      // Jump to next map square, either in x-direction, or y-direction
      if(sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }
      // Check if ray has hit a wall or door
      if(map[mapX] && map[mapX][mapY] > 0) hit = 1;
    }

    // Calculate distance projected on camera direction (correct for fish-eye)
    if(side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
    else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

    // Calculate height of line to draw
    let lineHeight = Math.floor(h / perpWallDist);

    // Determine wall or door type and adjust appearance
    const tileType = map[mapX][mapY];

    // Draw the vertical line for wall or door
    if(tileType === 1) {
      // Wall - solid gray
      ctx.fillStyle = side === 1 ? "#888" : "#BBB";
      ctx.fillRect(x, (h - lineHeight) / 2, 1, lineHeight);
    } else if(tileType === 2) {
      // Door - bigger and brownish
      // Let's make door twice as wide by drawing two adjacent vertical stripes
      ctx.fillStyle = side === 1 ? "#553311" : "#774422";
      ctx.fillRect(x, (h - lineHeight) / 2, 1, lineHeight);

      // Also draw the next stripe for door width (if in bounds)
      if (x + 1 < w) {
        ctx.fillRect(x + 1, (h - lineHeight) / 2, 1, lineHeight);
      }
    }
  }

  // Draw items as small 3D floor sprites on the ground
  items.forEach(item => {
    const spriteX = item.x - posX;
    const spriteY = item.y - posY;

    const invDet = 1 / (planeX * dirY - dirX * planeY);

    const transformX = invDet * (dirY * spriteX - dirX * spriteY);
    const transformY = invDet * (-planeY * spriteX + planeX * spriteY);

    if(transformY > 0) {
      const spriteScreenX = Math.floor((w / 2) * (1 + transformX / transformY));

      // base size depending on distance
      const baseSize = h / transformY;

      // Items smaller and on ground (floor sprites)
      const spriteHeight = baseSize / 8; // very small height for floor item
      const spriteWidth = spriteHeight;

      // Draw near bottom of screen to simulate ground
      const drawStartY = h - spriteHeight - 10; // 10px above bottom edge
      const drawEndY = drawStartY + spriteHeight;

      const drawStartX = spriteScreenX - spriteWidth / 2;
      const drawEndX = drawStartX + spriteWidth;

      // Draw the item rectangle (yellow for visibility)
      ctx.fillStyle = "yellow";
      ctx.fillRect(drawStartX, drawStartY, spriteWidth, spriteHeight);

      // Draw item name above item (small font)
      ctx.fillStyle = "white";
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(item.name, spriteScreenX, drawStartY - 5);
    }
  });
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
