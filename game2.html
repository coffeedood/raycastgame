<!DOCTYPE html>
<html>
<head>
  <title>Raycaster with Elevator</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:black; height:100%; width:100%; }
    canvas { display:block; }
    #fullscreenBtn {
      position:absolute; top:10px; left:10px; z-index:1000;
      padding:8px 12px; background:#222; color:white;
      border:none; cursor:pointer; font-size:14px; border-radius:4px;
    }
  </style>
</head>
<body>
  <button id="fullscreenBtn">Go Fullscreen</button>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    function resize(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);
    document.getElementById("fullscreenBtn").onclick = () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    };

    const floor1 = [
      "####################",
      "#..................#",
      "#..................#",
      "#..................#",
      "#..................#",
      "#..................#",
      "#.......######.....#",
      "#.......#....#.....#",
      "#.......#....B.....#",
      "#.......#....#.....#",
      "#.......######.....#",
      "#..................#",
      "#..................#",
      "#..................#",
      "#..................#",
      "####################"
    ];
    const floor2 = floor1.map(row => row);  // identical layout

    let currentMap = floor1;
    let posX = 2.5, posY = 2.5;
    let dirX = 1, dirY = 0;
    let planeX = 0, planeY = 0.66;
    const keys = {};
    let selectingFloor = false;
    let selectedFloor = 1;

    document.addEventListener("keydown", e=>{
      keys[e.key.toLowerCase()] = true;
      if(selectingFloor){
        if(e.key.toLowerCase()==="w"||e.key==="ArrowUp"){
          selectedFloor = Math.max(1, selectedFloor-1);
        } else if(e.key.toLowerCase()==="s"||e.key==="ArrowDown"){
          selectedFloor = Math.min(2, selectedFloor+1);
        } else if(e.key==="Enter"){
          simulateElevator(selectedFloor);
          selectingFloor = false;
        }
        e.preventDefault();
      }
    });
    document.addEventListener("keyup", e=>{ keys[e.key.toLowerCase()] = false; });

    function simulateElevator(floor){
      // Save old position
      const oldX = posX, oldY = posY;
      // Swap floors
      currentMap = (floor === 1) ? floor1 : floor2;
      // If new position is a wall/building here, fallback to closest open tile
      const mx = Math.floor(oldX), my = Math.floor(oldY);
      if(currentMap[my][mx] === '.'){
        posX = oldX; posY = oldY;
      } else {
        // search around
        const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
        let found = false;
        for(const [dx,dy] of dirs){
          if(found) break;
          const nx = mx+dx, ny = my+dy;
          if(currentMap[ny] && currentMap[ny][nx]==='.'){
            posX = nx + 0.5; posY = ny + 0.5;
            found = true;
          }
        }
        if(!found){
          posX = 2.5; posY = 2.5;
        }
      }
    }

    function gameLoop(){
      const w = canvas.width, h = canvas.height;
      ctx.fillStyle = "black";
      ctx.fillRect(0,0,w,h);
      for(let x=0; x<w; x++){
        const cameraX = 2*x/w - 1;
        const rayDirX = dirX + planeX*cameraX;
        const rayDirY = dirY + planeY*cameraX;
        let mapX = Math.floor(posX), mapY = Math.floor(posY);
        let sideDistX, sideDistY;
        const deltaDistX = Math.abs(1/rayDirX), deltaDistY = Math.abs(1/rayDirY);
        let stepX, stepY, side, hit=0;
        if(rayDirX < 0){
          stepX = -1; sideDistX = (posX-mapX)*deltaDistX;
        } else {
          stepX = 1; sideDistX = (mapX+1-posX)*deltaDistX;
        }
        if(rayDirY < 0){
          stepY = -1; sideDistY = (posY-mapY)*deltaDistY;
        } else {
          stepY = 1; sideDistY = (mapY+1-posY)*deltaDistY;
        }
        let hitChar = '.';
        while(!hit){
          if(sideDistX < sideDistY){
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          hitChar = currentMap[mapY][mapX];
          if(hitChar === '#' || hitChar === 'B') hit = 1;
        }
        const perpDist = side===0
          ? (mapX-posX + (1-stepX)/2)/rayDirX
          : (mapY-posY + (1-stepY)/2)/rayDirY;
        const lineH = Math.floor(h/perpDist);
        const drawS = -lineH/2+h/2;
        const drawE = lineH/2+h/2;
        let color;
        if(hitChar === '#'){
          const shade = side ? 180 : 255;
          color = `rgb(${shade},${shade},${shade})`;
        } else {
          color = side ? `rgb(100,180,255)` : `rgb(130,210,255)`;
        }
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, drawS);
        ctx.lineTo(x, drawE);
        ctx.stroke();
      }

      const ms = 0.05, rs = 0.03;
      const fy = posY + dirY*ms, fx = posX + dirX*ms;
      if(!selectingFloor){
        if(keys['w']||keys['arrowup']){
          if(currentMap[Math.floor(posY)][Math.floor(fx)] === '.') posX = fx;
          if(currentMap[Math.floor(fy)][Math.floor(posX)] === '.') posY = fy;
        }
        const by = posY - dirY*ms, bx = posX - dirX*ms;
        if(keys['s']||keys['arrowdown']){
          if(currentMap[Math.floor(posY)][Math.floor(bx)] === '.') posX = bx;
          if(currentMap[Math.floor(by)][Math.floor(posX)] === '.') posY = by;
        }
        if(keys['arrowleft']||keys['arrowright']){
          const angle = keys['arrowright'] ? rs : -rs;
          const odx = dirX, opx = planeX;
          dirX = odx*Math.cos(angle) - dirY*Math.sin(angle);
          dirY = odx*Math.sin(angle) + dirY*Math.cos(angle);
          planeX = opx*Math.cos(angle) - planeY*Math.sin(angle);
          planeY = opx*Math.sin(angle) + planeY*Math.cos(angle);
        }
      }

      if(keys['e']){
        const fx2 = Math.floor(posX+dirX), fy2 = Math.floor(posY+dirY);
        if(currentMap[fy2] && currentMap[fy2][fx2]==='B'){
          selectingFloor = true;
          selectedFloor = (currentMap===floor1 ? 2 : 1);
        }
      }

      // Mini-map
      const tile = 5;
      const ox = w - currentMap[0].length*tile - 10, oy = 10;
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(ox-2, oy-2, currentMap[0].length*tile+4, currentMap.length*tile+4);
      for(let y=0; y<currentMap.length; y++){
        for(let x=0; x<currentMap[0].length; x++){
          const c = currentMap[y][x];
          ctx.fillStyle = c==='.' ? "#222" : (c==='B' ? "#0af" : "#888");
          ctx.fillRect(ox + x*tile, oy + y*tile, tile, tile);
        }
      }
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(ox + posX*tile, oy + posY*tile, 2, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(ox + posX*tile, oy + posY*tile);
      ctx.lineTo(ox + (posX + dirX*0.7)*tile, oy + (posY + dirY*0.7)*tile);
      ctx.stroke();

      if(selectingFloor){
        ctx.fillStyle = "white";
        ctx.font = "20px monospace";
        ctx.fillText("Select Floor: " + selectedFloor, 20, 40);
        ctx.fillText("Up/Down to choose, Enter to confirm", 20, 70);
      }

      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
