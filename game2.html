<!DOCTYPE html>
<html>
<head>
  <title>Raycaster with Items and Multiple Floors</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black;
      height: 100%; width: 100%;
    }
    canvas { display: block; }
    #fullscreenBtn {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1000;
      padding: 8px 12px;
      background: #222;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 14px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <button id="fullscreenBtn">Go Fullscreen</button>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    document.getElementById("fullscreenBtn").onclick = () => {
      if (!document.fullscreenElement)
        document.documentElement.requestFullscreen();
      else
        document.exitFullscreen();
    };

    const maps = {
      1: [
        "####################",
        "#..................#",
        "#.......i..........#",
        "#.......D..........#",
        "#..................#",
        "#.......######.....#",
        "#.......#....#.....#",
        "#.......#....#.....#",
        "#.......#....#.....#",
        "#........B####.....#",
        "#..................#",
        "#..................#",
        "#..................#",
        "#..................#",
        "#..................#",
        "####################"
      ],
      2: [
        "####################",
        "#..................#",
        "#..................#",
        "#..................#",
        "#.......D..........#",
        "#.......i..........#",
        "#.......######.....#",
        "#.......#....#.....#",
        "#.......#....#.....#",
        "#......####..#.....#",
        "#......D.B####.....#",
        "#......####........#",
        "#..................#",
        "#..................#",
        "#..................#",
        "####################"
      ],
      3: [
        "####################",
        "#.......i..........#",
        "#..................#",
        "#..................#",
        "#.......D..........#",
        "#..................#",
        "#.......######.....#",
        "#.......#....#.....#",
        "#.......#....#.....#",
        "#......####..#.....#",
        "#......D.B####.....#",
        "#......####........#",
        "#..................#",
        "#..................#",
        "#..................#",
        "####################"
      ]
    };

    let currentFloor = 1;
    let currentMap = maps[currentFloor];

    const playerPositions = {
      1: { x: 8.5, y: 10.5 },
      2: { x: 8.5, y: 10.5 },
      3: { x: 8.5, y: 10.5 }
    };

    let posX = playerPositions[currentFloor].x;
    let posY = playerPositions[currentFloor].y;
    let dirX = 1, dirY = 0;
    let planeX = 0, planeY = 0.66;
    const keys = {};

    document.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (selectingFloor) {
        if (e.key.toLowerCase() === "w" || e.key === "ArrowUp") {
          selectedFloor = Math.max(1, selectedFloor - 1);
        } else if (e.key.toLowerCase() === "s" || e.key === "ArrowDown") {
          selectedFloor = Math.min(maxFloor, selectedFloor + 1);
        } else if (e.key === "Enter") {
          simulateElevator(selectedFloor);
          selectingFloor = false;
        }
        e.preventDefault();
      }
    });

    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    const maxFloor = 3;
    let selectingFloor = false;
    let selectedFloor = 1;
    let eKeyPressed = false;
    const inventory = [];
    let health = 100;

    function simulateElevator(floor) {
      playerPositions[currentFloor] = { x: posX, y: posY };
      currentFloor = floor;
      currentMap = maps[floor];
      posX = playerPositions[floor].x;
      posY = playerPositions[floor].y;
    }

    function drawHUD() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.fillStyle = "#000";
      ctx.fillRect(20, h - 50, 204, 24);
      ctx.fillStyle = "#f00";
      ctx.fillRect(22, h - 48, 2 * health, 20);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(20, h - 50, 204, 24);

      ctx.fillStyle = "#fff";
      ctx.font = "16px monospace";
      ctx.fillText("Health: " + health, 25, h - 25);
      ctx.fillText("Inventory: " + (inventory.length > 0 ? inventory.join(", ") : "Empty"), 240, h - 25);
    }

    function replaceAt(str, index, replacement) {
      return str.substring(0, index) + replacement + str.substring(index + 1);
    }

    function gameLoop() {
      const w = canvas.width, h = canvas.height;
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, w, h);

      for (let x = 0; x < w; x++) {
        const cameraX = 2 * x / w - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;

        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);

        let sideDistX, sideDistY;
        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let stepX, stepY, side, hit = 0, hitChar = '';

        if (rayDirX < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }

        if (rayDirY < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }

        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          hitChar = currentMap[mapY][mapX];
          if (hitChar !== '.') hit = 1;
        }

        const perpWallDist = side === 0
          ? (mapX - posX + (1 - stepX) / 2) / rayDirX
          : (mapY - posY + (1 - stepY) / 2) / rayDirY;

        let lineHeight = Math.floor(h / perpWallDist);
        let drawStart = -lineHeight / 2 + h / 2;
        let drawEnd = lineHeight / 2 + h / 2;

        if (hitChar === 'i') {
          const itemHeight = 5;
          drawStart = h - itemHeight - 10; // Near floor
          drawEnd = drawStart + itemHeight;
        }

        let color;
        if (hitChar === '#') color = side ? "#aaa" : "#ccc";
        else if (hitChar === 'B') color = "#33f";
        else if (hitChar === 'D') color = "#a52a2a";
        else if (hitChar === 'i') color = "#ff0";

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, drawStart);
        ctx.lineTo(x, drawEnd);
        ctx.stroke();
      }

      if (!selectingFloor) {
        const moveSpeed = 0.05, rotSpeed = 0.03;
        const forwardX = posX + dirX * moveSpeed, forwardY = posY + dirY * moveSpeed;
        if (keys['w'] || keys['arrowup']) {
          if (currentMap[Math.floor(posY)][Math.floor(forwardX)] === '.') posX = forwardX;
          if (currentMap[Math.floor(forwardY)][Math.floor(posX)] === '.') posY = forwardY;
        }
        if (keys['s'] || keys['arrowdown']) {
          if (currentMap[Math.floor(posY)][Math.floor(posX - dirX * moveSpeed)] === '.') posX -= dirX * moveSpeed;
          if (currentMap[Math.floor(posY - dirY * moveSpeed)][Math.floor(posX)] === '.') posY -= dirY * moveSpeed;
        }
        if (keys['arrowleft']) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
          dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
          planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
        }
        if (keys['arrowright']) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
          dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
          planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
        }
      }

      if (keys['e'] && !eKeyPressed) {
        eKeyPressed = true;
        const frontX = Math.floor(posX + dirX);
        const frontY = Math.floor(posY + dirY);
        const frontTile = currentMap[frontY]?.[frontX];
        if (frontTile === 'B') {
          selectingFloor = true;
          selectedFloor = currentFloor;
        } else if (frontTile === 'i') {
          inventory.push("Item");
          currentMap[frontY] = replaceAt(currentMap[frontY], frontX, '.');
        }
      }
      if (!keys['e']) eKeyPressed = false;

      if (selectingFloor) {
        ctx.fillStyle = "#fff";
        ctx.font = "20px monospace";
        ctx.fillText("Select Floor: " + selectedFloor, 20, 40);
        ctx.fillText("W/S or Up/Down to choose, Enter to confirm", 20, 70);
      }

      drawHUD();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
