<!DOCTYPE html>
<html>
<head>
  <title>Raycaster with Larger Map, Big Doors, and Small Items</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black;
      height: 100%; width: 100%;
    }
    canvas { display: block; margin: 0 auto; background: #333; }
  </style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<script>
// Original small map (9x9)
const originalMap = [
  "#########",
  "#.......#",
  "#.d..i..#",
  "#.......#",
  "#..####.#",
  "#..#..#.#",
  "#..#..#.#",
  "#.......#",
  "#########"
];

// Function to scale up the map by doubling each tile into 2x2 block
function scaleMap(map) {
  const scaledMap = [];
  for(let y=0; y<map.length; y++) {
    const row1 = [];
    const row2 = [];
    for(let x=0; x<map[y].length; x++) {
      const ch = map[y][x];
      // For doors ('d'), make 2x2 block of 'd'
      // For others, repeat char 2x
      let tile = ch;
      if(ch === 'd') {
        tile = 'd'; // door tile
      } else if(ch === '#') {
        tile = '#';
      } else if(ch === 'i') {
        tile = 'i'; // item single tile only
      } else {
        tile = '.'; // empty floor for others
      }
      row1.push(tile, tile);
      row2.push(tile, tile);
    }
    scaledMap.push(row1.join(''));
    scaledMap.push(row2.join(''));
  }
  return scaledMap;
}

const map = scaleMap(originalMap);
const mapWidth = map[0].length;
const mapHeight = map.length;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const screenWidth = canvas.width;
const screenHeight = canvas.height;

const tileSize = 1; // raycasting uses map grid units (no pixel size here)

// Player start position (in map units)
let posX = 3.5 * 2; // scaled by 2 because map is bigger
let posY = 3.5 * 2;

let dirX = -1;
let dirY = 0;
let planeX = 0;
let planeY = 0.66;

// Movement controls
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Collect all items' positions from the map
function getItems() {
  const items = [];
  for(let y=0; y<mapHeight; y++) {
    for(let x=0; x<mapWidth; x++) {
      if(map[y][x] === 'i') {
        // Position at center of tile
        items.push({x: x + 0.5, y: y + 0.5});
      }
    }
  }
  return items;
}
const items = getItems();

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function update() {
  const moveSpeed = 0.05; // movement speed
  const rotSpeed = 0.03;

  // Move forward
  if(keys['w']) {
    if(map[Math.floor(posY)][Math.floor(posX + dirX * moveSpeed)] === '.') posX += dirX * moveSpeed;
    if(map[Math.floor(posY + dirY * moveSpeed)][Math.floor(posX)] === '.') posY += dirY * moveSpeed;
  }
  // Move backward
  if(keys['s']) {
    if(map[Math.floor(posY)][Math.floor(posX - dirX * moveSpeed)] === '.') posX -= dirX * moveSpeed;
    if(map[Math.floor(posY - dirY * moveSpeed)][Math.floor(posX)] === '.') posY -= dirY * moveSpeed;
  }
  // Rotate right
  if(keys['d']) {
    let oldDirX = dirX;
    dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
    dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
    let oldPlaneX = planeX;
    planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
    planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
  }
  // Rotate left
  if(keys['a']) {
    let oldDirX = dirX;
    dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
    dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
    let oldPlaneX = planeX;
    planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
    planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
  }
}

function draw() {
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, screenWidth, screenHeight);

  for(let x=0; x < screenWidth; x++) {
    // Calculate ray position and direction
    const cameraX = 2 * x / screenWidth - 1;
    const rayDirX = dirX + planeX * cameraX;
    const rayDirY = dirY + planeY * cameraX;

    // Map position
    let mapX = Math.floor(posX);
    let mapY = Math.floor(posY);

    // Length of ray from current position to next x or y side
    let sideDistX;
    let sideDistY;

    // Length of ray from one x or y side to next x or y side
    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);
    let perpWallDist;

    // Step direction and initial sideDist
    let stepX;
    let stepY;

    let hit = 0;
    let side; // 0 for x, 1 for y

    // Calculate step and initial sideDist
    if(rayDirX < 0) {
      stepX = -1;
      sideDistX = (posX - mapX) * deltaDistX;
    } else {
      stepX = 1;
      sideDistX = (mapX + 1.0 - posX) * deltaDistX;
    }
    if(rayDirY < 0) {
      stepY = -1;
      sideDistY = (posY - mapY) * deltaDistY;
    } else {
      stepY = 1;
      sideDistY = (mapY + 1.0 - posY) * deltaDistY;
    }

    // Perform DDA
    while(hit === 0) {
      if(sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }
      // Check if ray has hit a wall or door
      if(map[mapY][mapX] === '#' || map[mapY][mapX] === 'd') hit = 1;
    }

    // Calculate distance projected on camera direction
    if(side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
    else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

    // Calculate height of line to draw
    let lineHeight = Math.floor(screenHeight / perpWallDist);

    // Draw walls or doors differently
    if(map[mapY][mapX] === '#') {
      ctx.fillStyle = 'gray';
    } else if(map[mapY][mapX] === 'd') {
      ctx.fillStyle = 'brown';
      lineHeight = Math.floor(lineHeight * 1.3); // make doors visually bigger/taller
    }

    // Give darker color for y sides
    if(side === 1) {
      ctx.fillStyle = shadeColor(ctx.fillStyle, -30);
    }

    // Calculate lowest and highest pixel to fill in current stripe
    let drawStart = Math.floor(-lineHeight / 2 + screenHeight / 2);
    if(drawStart < 0) drawStart = 0;
    let drawEnd = Math.floor(lineHeight / 2 + screenHeight / 2);
    if(drawEnd >= screenHeight) drawEnd = screenHeight - 1;

    // Draw vertical line for wall or door
    ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
  }

  drawSprites();
}

// Utility to shade color (simple brightness change)
function shadeColor(color, percent) {
  const f=parseInt(color.slice(1),16);
  const t=percent<0?0:255;
  const p=percent<0?percent*-1:percent;
  const R=f>>16;
  const G=f>>8&0x00FF;
  const B=f&0x0000FF;
  const newR = Math.min(255, Math.max(0, Math.round((t - R) * p / 100 + R)));
  const newG = Math.min(255, Math.max(0, Math.round((t - G) * p / 100 + G)));
  const newB = Math.min(255, Math.max(0, Math.round((t - B) * p / 100 + B)));
  return "#" + (0x1000000 + (newR << 16) + (newG << 8) + newB).toString(16).slice(1);
}

function drawSprites() {
  items.forEach(item => {
    // Vector from player to item
    const dx = item.x - posX;
    const dy = item.y - posY;

    // Inverse determinant for camera matrix
    const invDet = 1.0 / (planeX * dirY - dirX * planeY);

    // Transform item position to camera space
    const transformX = invDet * (dirY * dx - dirX * dy);
    const transformY = invDet * (-planeY * dx + planeX * dy);

    if(transformY <= 0) return; // behind player, skip

    const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));

    // Size of sprite (smaller than walls)
    const spriteHeight = Math.abs(Math.floor(screenHeight / transformY / 3)); // smaller size divisor makes it smaller
    const spriteWidth = spriteHeight; // square sprite

    // Vertical position (draw sprite "on floor", so shifted downward)
    const drawStartY = Math.floor(screenHeight / 2 + spriteHeight / 2);
    const drawStartX = spriteScreenX - spriteWidth / 2;

    // Draw item as a yellow rectangle (replace with image if you want)
    ctx.fillStyle = "yellow";
    ctx.fillRect(drawStartX, drawStartY, spriteWidth, spriteHeight);
  });
}

gameLoop();
</script>
</body>
</html>
