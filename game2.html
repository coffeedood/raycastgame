// This JavaScript code adds variable-height wall support to a raycasting engine.
// It assumes walls are stored in a grid, and each cell contains an object like { type: 'wall', height: 1.0 }

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = 800;
canvas.height = 600;

const map = [
  [ {type: 'wall', height: 1}, {type: 'wall', height: 1.5}, {type: 'wall', height: 0.5}, {type: 'empty'} ],
  [ {type: 'wall', height: 1}, {type: 'empty'}, {type: 'wall', height: 1}, {type: 'empty'} ],
  [ {type: 'wall', height: 1}, {type: 'empty'}, {type: 'wall', height: 1}, {type: 'empty'} ],
  [ {type: 'wall', height: 1}, {type: 'wall', height: 1}, {type: 'wall', height: 1}, {type: 'wall', height: 1} ]
];

const mapWidth = map[0].length;
const mapHeight = map.length;

const player = {
  x: 1.5,
  y: 1.5,
  dir: Math.PI / 4,
  fov: Math.PI / 3
};

function castRay(angle) {
  const dx = Math.cos(angle);
  const dy = Math.sin(angle);

  let distance = 0;
  while (distance < 20) {
    const x = player.x + dx * distance;
    const y = player.y + dy * distance;

    const mapX = Math.floor(x);
    const mapY = Math.floor(y);

    if (mapX >= 0 && mapX < mapWidth && mapY >= 0 && mapY < mapHeight) {
      const cell = map[mapY][mapX];
      if (cell && cell.type === 'wall') {
        return { distance, height: cell.height };
      }
    } else {
      break;
    }
    distance += 0.01;
  }
  return null;
}

function render() {
  ctx.fillStyle = 'skyblue';
  ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
  ctx.fillStyle = 'gray';
  ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

  const numRays = canvas.width;
  for (let i = 0; i < numRays; i++) {
    const rayAngle = player.dir - player.fov / 2 + player.fov * (i / numRays);
    const ray = castRay(rayAngle);

    if (ray) {
      const correctedDist = ray.distance * Math.cos(rayAngle - player.dir);
      const wallHeight = (canvas.height / correctedDist) * ray.height;
      ctx.fillStyle = 'brown';
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }
}

function gameLoop() {
  render();
  requestAnimationFrame(gameLoop);
}

gameLoop();
