<!DOCTYPE html>
<html>
<head>
  <title>Raycasting with Movement</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black;
      height: 100%; width: 100%;
    }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// MAP: 0 = walkable, >0 = wall of varying height
const map = [
  [1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,1],
  [1,0,2,0,3,0,0,1],
  [1,0,0,0,0,4,0,1],
  [1,0,0,5,0,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1]
];

// Start in an open space
let posX = 3.5, posY = 3.5;
let dirX = -1, dirY = 0;
let planeX = 0, planeY = 0.66;

const keys = {};
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function isWalkable(x, y) {
  const mx = Math.floor(x);
  const my = Math.floor(y);
  return map[my] && map[my][mx] === 0;
}

function gameLoop() {
  const w = canvas.width;
  const h = canvas.height;

  ctx.fillStyle = "skyblue";
  ctx.fillRect(0, 0, w, h / 2);
  ctx.fillStyle = "darkgreen";
  ctx.fillRect(0, h / 2, w, h / 2);

  for (let x = 0; x < w; x++) {
    const cameraX = 2 * x / w - 1;
    const rayDirX = dirX + planeX * cameraX;
    const rayDirY = dirY + planeY * cameraX;

    let mapX = Math.floor(posX);
    let mapY = Math.floor(posY);

    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);

    let stepX, stepY, sideDistX, sideDistY;
    if (rayDirX < 0) {
      stepX = -1;
      sideDistX = (posX - mapX) * deltaDistX;
    } else {
      stepX = 1;
      sideDistX = (mapX + 1.0 - posX) * deltaDistX;
    }

    if (rayDirY < 0) {
      stepY = -1;
      sideDistY = (posY - mapY) * deltaDistY;
    } else {
      stepY = 1;
      sideDistY = (mapY + 1.0 - posY) * deltaDistY;
    }

    let hit = false, side, height = 0;
    while (!hit) {
      if (sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }

      const cell = map[mapY]?.[mapX] ?? 0;
      if (cell > 0) {
        hit = true;
        height = cell;
      }
    }

    const perpWallDist = side === 0
      ? (mapX - posX + (1 - stepX) / 2) / rayDirX
      : (mapY - posY + (1 - stepY) / 2) / rayDirY;

    const lineHeight = Math.floor((h / perpWallDist) * (height / 1.5));
    const drawStart = Math.max(0, -lineHeight / 2 + h / 2);
    const drawEnd = Math.min(h, lineHeight / 2 + h / 2);

    const shade = side === 1 ? 0.7 : 1;
    const color = 255 - height * 30;
    ctx.strokeStyle = `rgb(${color * shade}, ${color * shade}, ${color * shade})`;
    ctx.beginPath();
    ctx.moveTo(x, drawStart);
    ctx.lineTo(x, drawEnd);
    ctx.stroke();
  }

  // Movement
  const moveSpeed = 0.05;
  const rotSpeed = 0.04;

  if (keys['w']) {
    const nextX = posX + dirX * moveSpeed;
    const nextY = posY + dirY * moveSpeed;
    if (isWalkable(nextX, posY)) posX = nextX;
    if (isWalkable(posX, nextY)) posY = nextY;
  }
  if (keys['s']) {
    const nextX = posX - dirX * moveSpeed;
    const nextY = posY - dirY * moveSpeed;
    if (isWalkable(nextX, posY)) posX = nextX;
    if (isWalkable(posX, nextY)) posY = nextY;
  }
  if (keys['a']) {
    const oldDirX = dirX;
    dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
    dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
    const oldPlaneX = planeX;
    planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
    planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
  }
  if (keys['d']) {
    const oldDirX = dirX;
    dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
    dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
    const oldPlaneX = planeX;
    planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
    planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
  }

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
