<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Raycaster with Variable Wall Heights and Transparency</title>
<style>
  body { margin:0; background: black; overflow: hidden; }
  canvas { display: block; margin: 0 auto; background: #222; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SCREEN_WIDTH = window.innerWidth;
const SCREEN_HEIGHT = window.innerHeight;
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

// Constants
const FOV = Math.PI / 3; // 60 degrees field of view
const NUM_RAYS = SCREEN_WIDTH;
const MAX_DEPTH = 20;
const MAP_SIZE = 10;
const TILE_SIZE = 1;

// Map with variable heights (0 = empty, >0 = wall height in units)
const map = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 1.5, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 1.5, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 1.5, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 1.5, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 1, 0, 0, 1.2, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 1.2, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 1.2, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 1.2, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
];

// Player state
let player = {
  x: 3.5,
  y: 3.5,
  angle: 0,
  moveSpeed: 3, // units per second
  rotSpeed: Math.PI, // radians per second
};

// Handle key input
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// Utility functions
function normalizeAngle(angle) {
  angle = angle % (2 * Math.PI);
  if (angle < 0) angle += 2 * Math.PI;
  return angle;
}

// Cast a ray, returns info about the hit
function castRay(rayAngle) {
  rayAngle = normalizeAngle(rayAngle);
  let sin = Math.sin(rayAngle);
  let cos = Math.cos(rayAngle);

  let distance = 0;
  let hit = false;
  let wallHeight = 0;
  let hitX = 0;
  let hitY = 0;
  let stepSize = 0.02;

  while (!hit && distance < MAX_DEPTH) {
    distance += stepSize;
    let testX = player.x + cos * distance;
    let testY = player.y + sin * distance;

    // Check map bounds
    if (testX < 0 || testX >= MAP_SIZE || testY < 0 || testY >= MAP_SIZE) {
      hit = true;
      distance = MAX_DEPTH;
      break;
    }

    let mapX = Math.floor(testX);
    let mapY = Math.floor(testY);

    if (map[mapY][mapX] > 0) {
      hit = true;
      wallHeight = map[mapY][mapX];
      hitX = testX;
      hitY = testY;
      break;
    }
  }
  return { distance, wallHeight, hitX, hitY, rayAngle };
}

function draw() {
  ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

  // Draw sky (simple gradient)
  let skyGradient = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT / 2);
  skyGradient.addColorStop(0, '#87ceeb');
  skyGradient.addColorStop(1, '#4682b4');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

  // Draw floor (simple color)
  ctx.fillStyle = '#444';
  ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

  // For each vertical slice (ray)
  for (let i = 0; i < NUM_RAYS; i++) {
    // Calculate ray angle relative to player direction
    let rayScreenPos = (i / NUM_RAYS) - 0.5;
    let rayAngle = player.angle + rayScreenPos * FOV;

    let ray = castRay(rayAngle);

    // Correct fisheye effect
    let correctedDist = ray.distance * Math.cos(rayAngle - player.angle);

    // Project wall height on screen
    // You can adjust the projection scale for better effect
    let projHeight = (1 / correctedDist) * SCREEN_HEIGHT * ray.wallHeight;

    let wallTop = (SCREEN_HEIGHT / 2) - projHeight;
    let wallBottom = (SCREEN_HEIGHT / 2) + projHeight;

    // Darken color based on distance for simple shading
    let shade = Math.min(1, 1 / (correctedDist * 0.5));
    let greyValue = Math.floor(150 * shade);
    let wallColor = `rgb(${greyValue},${greyValue},${greyValue})`;

    // Draw wall slice
    ctx.fillStyle = wallColor;
    ctx.fillRect(i, wallTop, 1, wallBottom - wallTop);

    // Draw transparent area above wall if wall is short (height < 1.5 for example)
    if (ray.wallHeight < 1.5) {
      let transparentTop = wallTop - (SCREEN_HEIGHT / 4); // amount of transparency above
      if (transparentTop < 0) transparentTop = 0;

      ctx.fillStyle = `rgba(128, 128, 128, 0.3)`; // grey transparent
      ctx.fillRect(i, transparentTop, 1, wallTop - transparentTop);
    }
  }
}

// Game loop
let lastTime = 0;
function gameLoop(timestamp = 0) {
  let delta = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  // Move player
  if (keys['ArrowLeft']) {
    player.angle -= player.rotSpeed * delta;
  }
  if (keys['ArrowRight']) {
    player.angle += player.rotSpeed * delta;
  }
  let moveStep = 0;
  if (keys['ArrowUp']) {
    moveStep = player.moveSpeed * delta;
  }
  if (keys['ArrowDown']) {
    moveStep = -player.moveSpeed * delta;
  }
  if (moveStep !== 0) {
    let newX = player.x + Math.cos(player.angle) * moveStep;
    let newY = player.y + Math.sin(player.angle) * moveStep;

    // Simple collision detection
    if (map[Math.floor(player.y)][Math.floor(newX)] == 0) player.x = newX;
    if (map[Math.floor(newY)][Math.floor(player.x)] == 0) player.y = newY;
  }

  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
