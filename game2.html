<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Raycaster with Small Items</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: black;
    height: 100%; width: 100%;
  }
  canvas {
    display: block;
    background: #111;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // Resize canvas to fill window
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  // Map legend:
  // '#' - wall
  // 'D' - door (treated as wall here, but could be special)
  // '.' - floor
  const map = [
    "################",
    "#..............#",
    "#....D.........#",
    "#..............#",
    "#..#######.....#",
    "#..............#",
    "#.....I........#",
    "################"
  ];

  const mapWidth = map[0].length;
  const mapHeight = map.length;

  // Player start position (x,y floats)
  let posX = 3.5;
  let posY = 3.5;

  // Player direction vector
  let dirX = 1;
  let dirY = 0;

  // Camera plane (perpendicular to dir vector)
  let planeX = 0;
  let planeY = 0.66;

  // Movement keys state
  const keys = {};
  window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
  window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

  // Items - separate from map
  // Each item has precise x,y coordinates (floats)
  const items = [
    { x: 6.3, y: 6.7, name: "Gold Coin" },
    { x: 5.8, y: 2.4, name: "Health Potion" },
  ];

  function isWall(x, y) {
    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return true;
    return map[Math.floor(y)][Math.floor(x)] === '#' || map[Math.floor(y)][Math.floor(x)] === 'D';
  }

  function gameLoop() {
    const w = canvas.width;
    const h = canvas.height;

    // Clear screen
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);

    // Raycasting to draw walls column by column
    for(let x = 0; x < w; x++) {
      // Camera x coordinate in camera space
      const cameraX = 2 * x / w - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;

      // Which box of the map we're in
      let mapX = Math.floor(posX);
      let mapY = Math.floor(posY);

      // Length of ray from one x or y side to next x or y side
      const deltaDistX = Math.abs(1 / rayDirX);
      const deltaDistY = Math.abs(1 / rayDirY);

      let stepX, stepY;
      let sideDistX, sideDistY;

      // Calculate step and initial sideDist
      if(rayDirX < 0) {
        stepX = -1;
        sideDistX = (posX - mapX) * deltaDistX;
      } else {
        stepX = 1;
        sideDistX = (mapX + 1.0 - posX) * deltaDistX;
      }
      if(rayDirY < 0) {
        stepY = -1;
        sideDistY = (posY - mapY) * deltaDistY;
      } else {
        stepY = 1;
        sideDistY = (mapY + 1.0 - posY) * deltaDistY;
      }

      let hit = false;
      let side; // 0 for x side, 1 for y side

      // Perform DDA (Digital Differential Analysis)
      while(!hit) {
        if(sideDistX < sideDistY) {
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        } else {
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        // Check if ray has hit a wall or door
        if(isWall(mapX, mapY)) hit = true;
      }

      // Calculate distance to the point of impact
      let perpWallDist;
      if(side === 0) {
        perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
      } else {
        perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
      }

      // Calculate height of line to draw on screen
      const lineHeight = Math.floor(h / perpWallDist);

      // Calculate lowest and highest pixel to fill in current stripe
      let drawStart = -lineHeight / 2 + h / 2;
      let drawEnd = lineHeight / 2 + h / 2;

      // Choose wall color
      let color;
      const cellChar = map[mapY][mapX];
      if(cellChar === '#') {
        color = side === 1 ? "rgb(120,120,120)" : "rgb(180,180,180)";
      } else if(cellChar === 'D') {
        color = side === 1 ? "rgb(139,69,19)" : "rgb(160,82,45)"; // door brown
      } else {
        color = "white";
      }

      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, drawStart);
      ctx.lineTo(x, drawEnd);
      ctx.stroke();
    }

    // Draw items as small squares (or circles) projected in the scene

    // We do a simple "sprite" projection here:
    // Calculate relative position of each item to player
    items.forEach(item => {
      // Translate item position to relative to camera
      const spriteX = item.x - posX;
      const spriteY = item.y - posY;

      // Inverse camera matrix
      const invDet = 1 / (planeX * dirY - dirX * planeY);

      const transformX = invDet * (dirY * spriteX - dirX * spriteY);
      const transformY = invDet * (-planeY * spriteX + planeX * spriteY);

      if(transformY > 0) { // Only draw if in front of camera

        const spriteScreenX = Math.floor((w / 2) * (1 + transformX / transformY));

        // Calculate height of the sprite on screen (smaller for items)
        const spriteHeight = Math.floor(h / transformY / 4); // Dividing by 4 to make items smaller
        const drawStartY = Math.floor(h / 2 - spriteHeight / 2);
        const drawEndY = drawStartY + spriteHeight;

        // Width same as height for square
        const spriteWidth = spriteHeight;
        const drawStartX = spriteScreenX - spriteWidth / 2;
        const drawEndX = drawStartX + spriteWidth;

        // Draw a yellow square as the item
        ctx.fillStyle = "yellow";
        ctx.fillRect(drawStartX, drawStartY, spriteWidth, spriteHeight);

        // Optional: draw item name above the item
        ctx.fillStyle = "white";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(item.name, spriteScreenX, drawStartY - 5);
      }
    });

    // Movement and rotation controls
    const moveSpeed = 0.05;
    const rotSpeed = 0.03;

    // Move forward
    if(keys['w']) {
      const newX = posX + dirX * moveSpeed;
      const newY = posY + dirY * moveSpeed;
      if(!isWall(newX, posY)) posX = newX;
      if(!isWall(posX, newY)) posY = newY;
    }
    // Move backward
    if(keys['s']) {
      const newX = posX - dirX * moveSpeed;
      const newY = posY - dirY * moveSpeed;
      if(!isWall(newX, posY)) posX = newX;
      if(!isWall(posX, newY)) posY = newY;
    }
    // Rotate left
    if(keys['a']) {
      const oldDirX = dirX;
      dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
      dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
      const oldPlaneX = planeX;
      planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
      planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
    }
    // Rotate right
    if(keys['d']) {
      const oldDirX = dirX;
      dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
      dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
      const oldPlaneX = planeX;
      planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
      planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
    }

    requestAnimationFrame(gameLoop);
  }

  gameLoop();
})();
</script>
</body>
</html>
