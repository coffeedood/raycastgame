<!DOCTYPE html>
<html>
<head>
  <title>Textured Raycasting Game (Fast)</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black; height: 100%; width: 100%;
    }
    canvas {
      display: block;
      position: absolute;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    const map = [
      "########",
      "#......#",
      "#..##..#",
      "#......#",
      "###..###",
      "#......#",
      "#......#",
      "########"
    ];

    let posX = 3.5, posY = 3.5;
    let dirX = 1, dirY = 0;
    let planeX = 0, planeY = 0.66;

    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    const wallTexture = new Image();
    wallTexture.src = "https://i.imgur.com/8bJHd5J.png"; // example texture (64x64)

    wallTexture.onload = () => {
      // Precut vertical stripes for fast rendering
      const texSlices = [];
      const texCanvas = document.createElement("canvas");
      texCanvas.width = wallTexture.width;
      texCanvas.height = wallTexture.height;
      const texCtx = texCanvas.getContext("2d");
      texCtx.drawImage(wallTexture, 0, 0);

      for (let x = 0; x < wallTexture.width; x++) {
        const slice = document.createElement("canvas");
        slice.width = 1;
        slice.height = wallTexture.height;
        const sliceCtx = slice.getContext("2d");
        sliceCtx.drawImage(texCanvas, x, 0, 1, wallTexture.height, 0, 0, 1, wallTexture.height);
        texSlices.push(slice);
      }

      function gameLoop() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, w, h);

        for (let x = 0; x < w; x++) {
          const cameraX = 2 * x / w - 1;
          const rayDirX = dirX + planeX * cameraX;
          const rayDirY = dirY + planeY * cameraX;

          let mapX = Math.floor(posX);
          let mapY = Math.floor(posY);

          let sideDistX, sideDistY;
          const deltaDistX = Math.abs(1 / rayDirX);
          const deltaDistY = Math.abs(1 / rayDirY);
          let perpWallDist;

          let stepX, stepY;
          let hit = 0, side;

          if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
          }

          if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
          }

          while (hit === 0) {
            if (sideDistX < sideDistY) {
              sideDistX += deltaDistX;
              mapX += stepX;
              side = 0;
            } else {
              sideDistY += deltaDistY;
              mapY += stepY;
              side = 1;
            }
            if (map[mapY][mapX] === "#") hit = 1;
          }

          if (side === 0)
            perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
          else
            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

          const lineHeight = Math.floor(h / perpWallDist);
          let drawStart = -lineHeight / 2 + h / 2;
          let drawEnd = lineHeight / 2 + h / 2;
          if (drawStart < 0) drawStart = 0;
          if (drawEnd >= h) drawEnd = h - 1;

          let wallX;
          if (side === 0) wallX = posY + perpWallDist * rayDirY;
          else wallX = posX + perpWallDist * rayDirX;
          wallX -= Math.floor(wallX);

          let texX = Math.floor(wallX * wallTexture.width);
          if (side === 0 && rayDirX > 0) texX = wallTexture.width - texX - 1;
          if (side === 1 && rayDirY < 0) texX = wallTexture.width - texX - 1;

          const texSlice = texSlices[texX];
          ctx.drawImage(texSlice, 0, 0, 1, wallTexture.height, x, drawStart, 1, drawEnd - drawStart);
        }

        // Controls
        const moveSpeed = 0.05;
        const rotSpeed = 0.03;

        if (keys["w"] || keys["arrowup"]) {
          if (map[Math.floor(posY)][Math.floor(posX + dirX * moveSpeed)] === ".") posX += dirX * moveSpeed;
          if (map[Math.floor(posY + dirY * moveSpeed)][Math.floor(posX)] === ".") posY += dirY * moveSpeed;
        }
        if (keys["s"] || keys["arrowdown"]) {
          if (map[Math.floor(posY)][Math.floor(posX - dirX * moveSpeed)] === ".") posX -= dirX * moveSpeed;
          if (map[Math.floor(posY - dirY * moveSpeed)][Math.floor(posX)] === ".") posY -= dirY * moveSpeed;
        }
        if (keys["a"] || keys["arrowright"]) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
          dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
          planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
        }
        if (keys["d"] || keys["arrowleft"]) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
          dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
          planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
        }

        requestAnimationFrame(gameLoop);
      }

      gameLoop();
    };
  </script>
</body>
</html>
